package pgraph.anya;

import org.jgrapht.traverse.EuclideanDistanceHeuristic;
import org.jgrapht.traverse.Heuristic;

import pgraph.grid.BitpackedGrid;

// AnyaHeuristic.h
//
//	A heuristic for evaluating search nodes generated by the
// 	Anya algorithm. A main difference between this heuristic
//  and other pathfinding heuristics is that a node in Anya
//  represents a set of locations from an interval, rather than
//  a single (x, y) coordinate.
//
//  For details, see:
// 	D. Harabor and A. Grastien, 2013,  
//  An Optimal Any-angle Pathfinding Algorithm,
//  International Conference on Planning and Scheduling (ICAPS)
//
//  @author: dharabor
//  @created: 2015-05-21
//


public class AnyaHeuristic implements Heuristic<AnyaNode> 
{
	private EuclideanDistanceHeuristic h;
	
	AnyaHeuristic() 
	{
		h = new EuclideanDistanceHeuristic();
	}
	
	@Override
	public double getValue(AnyaNode n) 
	{
		return 0;
	}

	@Override
	public double getValue(AnyaNode n, AnyaNode t) 
	{
		assert( (t.root.y == t.interval.getRow()) &&
				(t.root.x == t.interval.getLeft()) && 
				(t.root.x == t.interval.getRight()));
		
		int irow = n.interval.getRow();
		double ileft = n.interval.getLeft();
		double iright = n.interval.getRight();
		double targetx = t.root.x;
		double targety = t.root.y;
		double rootx = n.root.x;
		double rooty = n.root.y;
		
		// root and target must be on opposite sides of the interval
		// (or both on the same row as the interval). we mirror the
		// target through the interval if this is not the case
		if((rooty < irow && targety < irow))
		{
			targety += 2*(irow - targety);

		}
		else if(rooty > irow && targety > irow) 
		{
			targety -= 2*(targety - irow);
		}
		
		// project the interval endpoints onto the target row
		double rise_root_to_irow = Math.abs(n.root.y - n.interval.getRow());
		double rise_irow_to_target = Math.abs(n.interval.getRow() - t.root.y);
		double lrun = n.root.x - n.interval.getLeft();
		double rrun = n.interval.getRight() - n.root.x;
		double left_proj = n.interval.getLeft() - rise_irow_to_target * (lrun / rise_root_to_irow);
		double right_proj = n.interval.getRight() + rise_irow_to_target * (rrun / rise_root_to_irow);
		
		if((t.root.x+BitpackedGrid.epsilon) < left_proj)
		{
			return // pass through the left endpoint
					h.h(rootx, rooty, ileft, irow) +
					h.h(ileft, irow, targetx, targety);	
		}
		if(t.root.x > (right_proj + BitpackedGrid.epsilon))
		{
			return // pass through the right endpoint
					h.h(rootx, rooty, iright, irow) +
					h.h(iright, irow, targetx, targety);				
		}
	
		//representative point is interior to the interval
		return h.h(rootx, rooty, targetx, targety);
	}
}
